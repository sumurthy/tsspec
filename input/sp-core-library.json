{
  "kind": "package",
  "exports": {
    "DisplayMode": {
      "kind": "enum",
      "values": {
        "Edit": {
          "value": "2",
          "summary": []
        },
        "Read": {
          "value": "1",
          "summary": []
        }
      },
      "summary": [
        {
          "kind": "textDocElement",
          "value": "DisplayMode indicates the mode in which a page and/or its contents (e.g. text and web parts) are dislayed."
        }
      ]
    },
    "Environment": {
      "kind": "class",
      "summary": [
        {
          "kind": "textDocElement",
          "value": "This class contains contextual information about the enviroment that is hosting the framework and its components."
        }
      ],
      "members": {
        "applicationSessionId": {
          "kind": "property",
          "isOptional": false,
          "isReadOnly": true,
          "isStatic": true,
          "type": "Guid",
          "summary": [
            {
              "kind": "textDocElement",
              "value": "A unique identifier used to correlate logging and other diagnostic information. Its lifetime persists for the duration of the client-side application instance, i.e. it begins with the server request that renders the page, and ends e.g. when the browser tab is closed or F5 is pressed to reload the page. Note that if the application's router supports in-place navigation (via the history.pushState() API), the application session persists across these transitions."
            }
          ]
        },
        "pageSessionId": {
          "kind": "property",
          "isOptional": false,
          "isReadOnly": true,
          "isStatic": true,
          "type": "Guid",
          "summary": [
            {
              "kind": "textDocElement",
              "value": "A unique identifier used to correlate logging and other diagnostic information. Whereas the applicationSessionId tracks the entire lifetime of the client-side application instance, the pageSessionId tracks an individual \"page\" that is rendered. For example, suppose that the application initially loads PageA, then the user does in-place navigation (via the history.pushState() API) to PageB, then navigates back to PageA, and finally they close the browser tab. During this sequence, the applicationSessionId will remain the same, however the pageSessionId will change on each navigation. The 3 different pageSessionId values are used by the diagnostics e.g. to track success/failure statistics for PageA independently of PageB. The concept of a \"page\" is application-defined."
            }
          ]
        },
        "type": {
          "kind": "property",
          "isOptional": false,
          "isReadOnly": true,
          "isStatic": true,
          "type": "EnvironmentType",
          "summary": [
            {
              "kind": "textDocElement",
              "value": "An enum that describes which type of enviroment the framework is running in."
            }
          ]
        }
      }
    },
    "EnvironmentType": {
      "kind": "enum",
      "values": {
        "ClassicSharePoint": {
          "value": "",
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Indicates that the framework was loaded from a classic server-rendered SharePoint page"
            }
          ]
        },
        "Local": {
          "value": "",
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Represents the scenario of the framework hosted on a localhost server, which typically cannot access any SharePoint REST APIs. Example: A developer uses gulp serve command to test their changes in their browser of choice."
            }
          ]
        },
        "SharePoint": {
          "value": "",
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Indicates that the framework was loaded by a client-rendered SharePoint page"
            }
          ]
        },
        "Test": {
          "value": "",
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Represents the scenario of the framework hosted in a unit/integration test. Example: A developer running a unit test to verify changes to their web part."
            }
          ]
        }
      },
      "summary": [
        {
          "kind": "textDocElement",
          "value": "An enum that describes which type of enviroment the framework is running in."
        }
      ]
    },
    "Guid": {
      "kind": "class",
      "summary": [
        {
          "kind": "textDocElement",
          "value": "This class represents a globally unique identifier, as described by IETF RFC 4122. The input string is normalized and validated, which provides important guarantees that simplify other code that works with the GUID. This class also provides basic support for generating a pseudo-random GUID; however, be aware that the uniqueness depends on the browser's Math.random() function and may be not be suitable for some applications."
        },
        {
          "kind": "seeDocElement",
          "seeElements": [
            {
              "kind": "linkDocElement",
              "targetUrl": "https://www.ietf.org/rfc/rfc4122.txt"
            }
          ]
        }
      ],
      "members": {
        "empty": {
          "kind": "property",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": true,
          "type": "Guid",
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Returns a new empty Guid instance."
            }
          ]
        },
        "equals": {
          "kind": "method",
          "signature": "public equals(guid: Guid): boolean;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "boolean",
            "description": [
              {
                "kind": "textDocElement",
                "value": "True if this instance and the specified Guid object represent the same value."
              }
            ]
          },
          "parameters": {},
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Compare this instance to another Guid instance"
            }
          ]
        },
        "isValid": {
          "kind": "method",
          "signature": "public static isValid(guid: string): boolean;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": true,
          "returnType": {
            "type": "boolean",
            "description": [
              {
                "kind": "textDocElement",
                "value": "true, if the Guid is valid."
              }
            ]
          },
          "parameters": {
            "guid": {
              "name": "guid",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "The input string."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Indicates whether a guid is valid, i.e. whether it would be successfully parsed by Guid.tryParse(). This function is cheaper than Guid.tryParse() because it does not construct a Guid object."
            }
          ]
        },
        "newGuid": {
          "kind": "method",
          "signature": "public static newGuid(randomNumberGenerator?: IRandomNumberGenerator): Guid;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": true,
          "returnType": {
            "type": "Guid",
            "description": [
              {
                "kind": "textDocElement",
                "value": "A new unique Guid object"
              }
            ]
          },
          "parameters": {},
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Returns a new Guid instance with a pseudo-randomly generated Guid, according to the version 4 UUID algorithm from RFC 4122."
            }
          ]
        },
        "parse": {
          "kind": "method",
          "signature": "public static parse(guidString: string): Guid;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": true,
          "returnType": {
            "type": "Guid",
            "description": [
              {
                "kind": "textDocElement",
                "value": "A valid Guid object"
              }
            ]
          },
          "parameters": {
            "guid": {
              "name": "guid",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "The input string."
                }
              ]
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Parses the input string to construct a new Guid object. If the string cannot be parsed, then an error is thrown."
            }
          ],
          "remarks": [
            {
              "kind": "textDocElement",
              "value": "Example syntaxes accepted by this function: 'd5369f3b-bd7a-412a-9c0f-7f0650bb5489' '{d5369f3b-bd7a-412a-9c0f-7f0650bb5489}' '/Guid(d5369f3b-bd7a-412a-9c0f-7f0650bb5489)'"
            }
          ]
        },
        "toString": {
          "kind": "method",
          "signature": "public toString(): string;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "string",
            "description": [
              {
                "kind": "textDocElement",
                "value": "The GUID value in lowercase hexadecimal without braces. Example: 'd5369f3b-bd7a-412a-9c0f-7f0650bb5489'"
              }
            ]
          },
          "parameters": {},
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Object.prototype.toString override"
            }
          ]
        },
        "tryParse": {
          "kind": "method",
          "signature": "public static tryParse(guid: string): Guid;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": true,
          "returnType": {
            "type": "Guid",
            "description": [
              {
                "kind": "textDocElement",
                "value": "The Guid object, or undefined if the string could not be parsed."
              }
            ]
          },
          "parameters": {
            "guid": {
              "name": "guid",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "The input string."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Attempts to parse the input string to construct a new Guid object. If the string cannot be parsed, then undefined is returned."
            }
          ],
          "remarks": [
            {
              "kind": "textDocElement",
              "value": "Example syntaxes accepted by this function: 'd5369f3b-bd7a-412a-9c0f-7f0650bb5489' '{d5369f3b-bd7a-412a-9c0f-7f0650bb5489}' '/Guid(d5369f3b-bd7a-412a-9c0f-7f0650bb5489)'"
            }
          ]
        }
      }
    },
    "IRandomNumberGenerator": {
      "kind": "interface",
      "summary": [
        {
          "kind": "textDocElement",
          "value": "This is a ServiceScope interface that enables unit tests to provide a deterministic source of pseudorandom numbers."
        }
      ],
      "members": {
        "generate": {
          "kind": "method",
          "signature": "generate(): number;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "number",
            "description": []
          },
          "parameters": {},
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Returns a psuedorandom number between 0 (inclusive) and 1 (exclusive), following the contract of Math.random()."
            }
          ]
        }
      }
    },
    "IServiceCollection": {
      "kind": "interface",
      "summary": [
        {
          "kind": "textDocElement",
          "value": "A shorthand pattern for extracting well-known services from a ServiceScope."
        }
      ],
      "remarks": [
        {
          "kind": "textDocElement",
          "value": "Reusable library components typically declare their service dependencies by calling ServiceScope.consume() using the corresponding ServiceKey for each service. For application business logic or small-sized projects, this formalism may be unnecessary and would increase the learning curve for developers. As a lightweight alternative, the IServiceCollection pattern allows the common services for a particular scenario to be passed around as a simple, convenient collection. For example, a widget feature might introduce an interface like this: interface IWidgetServiceCollection extends IServiceCollection { spHttpClient: SPHttpClient; widgetManager: IWidgetManager; } Then the Widget class might initialize a \"services\" property, like this: class Widget { private _services: IWidgetServiceCollection; constructor(serviceScope: ServiceScope) { serviceScope.whenFinished(() => { this._services = { serviceScope, spHttpClient: serviceScope.consume(SPHttpClient.serviceKey), widgetManager: serviceScope.consume(WidgetManager.ServiceKey), }; }); } public get services(): IWidgetServiceCollection { return this._services; } } For a group of components that all have these dependencies, this \"services\" object can be passed around instead of the abstract ServiceScope. This enables direct references such as services.widgetManager, services.spHttpClient, etc. For atypical dependencies, the services.serviceScope is still available for use. IMPORTANT: To keep the pattern clean and understandable, IServiceCollection should NOT be extended with any additional members that are not ServiceScope services."
        }
      ],
      "members": {
        "serviceScope": {
          "kind": "property",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "ServiceScope",
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Returns the underlying ServiceScope that the members belong to."
            }
          ]
        }
      }
    },
    "ITimeProvider": {
      "kind": "interface",
      "summary": [
        {
          "kind": "textDocElement",
          "value": "This is a ServiceScope interface that enables unit tests to simulate the system clock."
        }
      ],
      "members": {
        "getDate": {
          "kind": "method",
          "signature": "getDate(): Date;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "Date",
            "description": []
          },
          "parameters": {},
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Returns the current date/time."
            }
          ]
        },
        "getTimestamp": {
          "kind": "method",
          "signature": "getTimestamp(): number;",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "number",
            "description": []
          },
          "parameters": {},
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Returns a DOMHighResTimeStamp timing measurement, as defined by the standard performance.now() API."
            }
          ]
        }
      }
    },
    "Log": {
      "kind": "class",
      "summary": [
        {
          "kind": "textDocElement",
          "value": "The Log class provides static methods for logging messages at different levels (verbose, info, warning, error) and with context information. Context information helps identify which component generated the messages and makes the messages useful and filterable."
        }
      ],
      "members": {
        "error": {
          "kind": "method",
          "signature": "public static error(source: string, error: Error, scope?: ServiceScope): void;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": true,
          "returnType": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "source": {
              "name": "source",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the source from where the error is logged, e.g., the class name. The source provides context information for the logged error. If the source's length is more than 20, only the first 20 characters are kept."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            },
            "error": {
              "name": "error",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the error to be logged"
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "Error"
            },
            "scope": {
              "name": "scope",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the service scope that the source uses. A service scope can provide more context information (e.g., web part information) to the logged error."
                }
              ],
              "isOptional": true,
              "isSpread": false,
              "type": "ServiceScope"
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Logs an error"
            }
          ]
        },
        "info": {
          "kind": "method",
          "signature": "public static info(source: string, message: string, scope?: ServiceScope): void;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": true,
          "returnType": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "source": {
              "name": "source",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the source from where the message is logged, e.g., the class name. The source provides context information for the logged message. If the source's length is more than 20, only the first 20 characters are kept."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            },
            "message": {
              "name": "message",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the message to be logged If the message's length is more than 100, only the first 100 characters are kept."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            },
            "scope": {
              "name": "scope",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the service scope that the source uses. A service scope can provide more context information (e.g., web part information) to the logged message."
                }
              ],
              "isOptional": true,
              "isSpread": false,
              "type": "ServiceScope"
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Logs an informational message"
            }
          ]
        },
        "verbose": {
          "kind": "method",
          "signature": "public static verbose(source: string, message: string, scope?: ServiceScope): void;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": true,
          "returnType": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "source": {
              "name": "source",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the source from where the message is logged, e.g., the class name. The source provides context information for the logged message. If the source's length is more than 20, only the first 20 characters are kept."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            },
            "message": {
              "name": "message",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the message to be logged If the message's length is more than 100, only the first 100 characters are kept."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            },
            "scope": {
              "name": "scope",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the service scope that the source uses. A service scope can provide more context information (e.g., web part information) to the logged message."
                }
              ],
              "isOptional": true,
              "isSpread": false,
              "type": "ServiceScope"
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Logs a verbose message"
            }
          ]
        },
        "warn": {
          "kind": "method",
          "signature": "public static warn(source: string, message: string, scope?: ServiceScope): void;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": true,
          "returnType": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "source": {
              "name": "source",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the source from where the message is logged, e.g., the class name. The source provides context information for the logged message. If the source's length is more than 20, only the first 20 characters are kept."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            },
            "message": {
              "name": "message",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the message to be logged If the message's length is more than 100, only the first 100 characters are kept."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            },
            "scope": {
              "name": "scope",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the service scope that the source uses. A service scope can provide more context information (e.g., web part information) to the logged message."
                }
              ],
              "isOptional": true,
              "isSpread": false,
              "type": "ServiceScope"
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Logs a warning"
            }
          ]
        }
      }
    },
    "RandomNumberGenerator": {
      "kind": "class",
      "implements": "IRandomNumberGenerator",
      "summary": [
        {
          "kind": "textDocElement",
          "value": "This is the default implementation of IRandomNumberGenerator that simply calls Math.random()."
        }
      ],
      "members": {
        "__constructor": {
          "kind": "method",
          "signature": "constructor(serviceScope: ServiceScope);",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "",
            "description": []
          },
          "parameters": {},
          "summary": []
        },
        "generate": {
          "kind": "method",
          "signature": "public generate(): number;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "number",
            "description": []
          },
          "parameters": {},
          "summary": []
        },
        "serviceKey": {
          "kind": "property",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": true,
          "type": "ServiceKey<IRandomNumberGenerator>",
          "summary": [
            {
              "kind": "textDocElement",
              "value": "The service key for IRandomNumberGenerator."
            }
          ]
        }
      }
    },
    "ServiceKey": {
      "kind": "class",
      "typeParameters": [
        "T"
      ],
      "summary": [
        {
          "kind": "textDocElement",
          "value": "The ServiceKey is a lookup key that is used when calling ServiceScope.consume() to fetch a dependency. The key also defines a default implementation of the dependency, which will be autocreated by the root scope if the dependency is not found. Providing a default implementation ensures that new dependencies can be safely introduced without inadvertently breaking components that are loaded by an older host (that does not provide the new dependency)."
        }
      ],
      "members": {
        "__constructor": {
          "kind": "method",
          "signature": "constructor(id: string, name: string, defaultCreator: ServiceCreator<T>);",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "",
            "description": []
          },
          "parameters": {},
          "summary": [
            {
              "kind": "textDocElement",
              "value": "PRIVATE - Do not call this from your own code."
            }
          ]
        },
        "create": {
          "kind": "method",
          "signature": "public static create < T >(name: string,\r\n    serviceClass: { new (serviceScope: ServiceScope); }): ServiceKey<T>;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": true,
          "returnType": {
            "type": "ServiceKey<T>",
            "description": [
              {
                "kind": "textDocElement",
                "value": "- the newly created ServiceKey"
              }
            ]
          },
          "parameters": {
            "name": {
              "name": "name",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "A name such as \"MyApplication.IMyService\" which should be unique within your application."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            },
            "serviceClass": {
              "name": "serviceClass",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the TypeScript class that implements the service."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "{ new (serviceScope: ServiceScope); }"
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Constructs a new ServiceKey whose default implementation will be a new instance of a TypeScript class that accepts the standard constructor parameter. If you want to specify custom constructor parameters, use createCustom() instead."
            }
          ]
        },
        "createCustom": {
          "kind": "method",
          "signature": "public static createCustom < T >(name: string, defaultCreator: ServiceCreator<T>): ServiceKey<T>;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": true,
          "returnType": {
            "type": "ServiceKey<T>",
            "description": [
              {
                "kind": "textDocElement",
                "value": "- the newly created ServiceKey"
              }
            ]
          },
          "parameters": {
            "name": {
              "name": "name",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "A name such as \"MyApplication.IMyService\" which should be unique within your application."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            },
            "defaultCreator": {
              "name": "defaultCreator",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "A callback that returns an object that implements the T interface"
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "ServiceCreator<T>"
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Constructs a new ServiceKey whose default implementation will be obtained by invoking the specified callback."
            }
          ]
        },
        "defaultCreator": {
          "kind": "property",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "ServiceCreator<T>",
          "summary": []
        },
        "id": {
          "kind": "property",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "string",
          "summary": []
        },
        "name": {
          "kind": "property",
          "isOptional": false,
          "isReadOnly": false,
          "isStatic": false,
          "type": "string",
          "summary": []
        }
      }
    },
    "ServiceScope": {
      "kind": "class",
      "summary": [
        {
          "kind": "textDocElement",
          "value": "ServiceScope provides a formalized way for components to register and consume dependencies (\"services\"), and to enable different implementations to be registered in different scopes. This improves modularity by decoupling components from their dependencies in an extensible way. For example, suppose that various components need access to an IPageManager instance. We could simply make the PageManager a singleton (i.e. global variable), but this will not work e.g. if we need to create a pop-up dialog that requires a second PageManager instance. A better solution would be to add the PageManager as a constructor parameter for each component that requires it, however then we immediately face the problem that any code that calls these constructors also needs a PageManager parameter. In an application with many such dependencies, business logic that ties together many subsystems would eventually pick up a constructor parameter for every possible dependency, which is unwieldy. A natural solution would be to move all the dependencies into a class with name like \"ApplicationContext\", and then pass this around as our constructor parameter. This enables the PageManager to be passed to classes that need it without cluttering the intermediary classes that don't. However, it still has a design problem that \"ApplicationContext\" has hard-coded dependencies on many unrelated things. A more flexible approach is to make it a dictionary that can look up items for consumers/providers who know the right lookup key (i.e. ServiceKey). This is the popular \"service locator\" design pattern, familiar from the SPContext API in classic SharePoint. ServiceScope takes this idea a step further in two important ways: First, it provides a scoping mechanism so that e.g. if we had two different pages, they could each consume a unique PageManager instance while still sharing other common dependencies. Secondly, it allows for a ServiceKey to provide a default implementation of the dependency. This is important for API stability in our modular client-side environment: For example, suppose that version 2.0 of our application introduced a new IDiagnosticTracing interface that a version 2.0 component will expect to consume. If the version 2.0 component gets loaded by an older 1.0 application, it would fail. We could fix this by requiring each consumer to check for any missing dependencies and handle that case, but it would require a lot of checks. A better solution is to ensure that a default implementation always exists, perhaps just a trivial behavior, so that components don't have to worry about it. Usage: ServiceScope instances are created by calling either ServiceScope.startNewRoot() or ServiceScope.startNewChild(). They are initially in an \"unfinished\" state, during which provide() can be called to register service keys, but consume() is forbidden. After ServiceScope.finish() is called, consume() is allowed and provide() is now forbidden. These semantics ensure that ServiceScope.consume() always returns the same result for the same key, and does not depend on order of initialization. It also allows us to support circular dependencies without worrying about infinite loops, even when working with external components that were implemented by third parties. To avoid mistakes, it's best to always call consume() inside a callback from serviceScope.whenFinished()."
        }
      ],
      "members": {
        "__constructor": {
          "kind": "method",
          "signature": "constructor(parent: ServiceScope);",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "",
            "description": []
          },
          "parameters": {},
          "summary": [
            {
              "kind": "textDocElement",
              "value": "PRIVATE CONSTRUCTOR - DO NOT CALL THIS FROM YOUR OWN CODE."
            }
          ]
        },
        "consume": {
          "kind": "method",
          "signature": "public consume < T >(serviceKey: ServiceKey<T>): T;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "T",
            "description": [
              {
                "kind": "textDocElement",
                "value": "- the service instance"
              }
            ]
          },
          "parameters": {
            "serviceKey": {
              "name": "serviceKey",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the key that was used when provide() was called to register the service"
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "ServiceKey<T>"
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Components should call this function to \"consume\" a dependency, i.e. look up the serviceKey and return the registered service instance. If the instance cannot be found, then a default instance will be autocreated and registered with the root ServiceScope."
            }
          ]
        },
        "createAndProvide": {
          "kind": "method",
          "signature": "public createAndProvide < T >(serviceKey: ServiceKey<T>,\r\n    simpleServiceClass: { new (serviceScope: ServiceScope); }): T;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "T",
            "description": [
              {
                "kind": "textDocElement",
                "value": "- a newly constructed instance of simpleServiceClass"
              }
            ]
          },
          "parameters": {
            "serviceKey": {
              "name": "serviceKey",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the key that can be used later to consume the service"
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "ServiceKey<T>"
            },
            "simpleServiceClass": {
              "name": "simpleServiceClass",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the TypeScript class to be constructed"
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "{ new (serviceScope: ServiceScope); }"
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "This is a shorthand function that its equivalent to constructing a new instance of the simpleServiceClass, then registering it by calling ServiceScope.provide()."
            }
          ]
        },
        "createDefaultAndProvide": {
          "kind": "method",
          "signature": "public createDefaultAndProvide < T >(serviceKey: ServiceKey<T>): T;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "T",
            "description": [
              {
                "kind": "textDocElement",
                "value": "- a service instance that was constructed using ServiceKey.defaultCreator"
              }
            ]
          },
          "parameters": {
            "serviceKey": {
              "name": "serviceKey",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the key that can be used later to consume the service"
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "ServiceKey<T>"
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "This is a shorthand function that constructs the default implementation of the specified serviceKey, and then registers it by calling ServiceScope.provide()."
            }
          ]
        },
        "finish": {
          "kind": "method",
          "signature": "public finish(): void;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "void",
            "description": []
          },
          "parameters": {},
          "summary": [
            {
              "kind": "textDocElement",
              "value": "When a ServiceScope is first started, it is in an \"unfinished\" state where provide() is allowed but consume() is not allowed. After calling finish(), then consume() is allowed but provide() is not allowed. This formalism completely eliminates a number of tricky bugs such as: Scope2 is a child of Scope1, and Scope1 provides instance A1 of interface A; if someone consumes A1 from Scope2 (via inheritance) before Scope2.provide() is called with A2, then a subsequent call to Scope2.consume() might return a different result than the previous call, which would be very confusing for developers."
            }
          ]
        },
        "getParent": {
          "kind": "method",
          "signature": "public getParent(): ServiceScope;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "ServiceScope",
            "description": [
              {
                "kind": "textDocElement",
                "value": "- the parent service scope"
              }
            ]
          },
          "parameters": {},
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Returns the parent of the current ServiceScope, or undefined if this is a root scope."
            }
          ]
        },
        "provide": {
          "kind": "method",
          "signature": "public provide < T >(serviceKey: ServiceKey<T>, service: T): T;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "T",
            "description": [
              {
                "kind": "textDocElement",
                "value": "- the same object that was passed as the \"service\" parameter"
              }
            ]
          },
          "parameters": {
            "serviceKey": {
              "name": "serviceKey",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the key that will later be used to consume the service"
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "ServiceKey<T>"
            },
            "service": {
              "name": "service",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the service instance that is being registered"
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "T"
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "ServiceScope.provide() is used to register an implemententation of the given serviceKey for the current scope. It may only be used when the ServiceScope is in an \"unfinished\" state, i.e. before finish() has been called."
            }
          ]
        },
        "startNewChild": {
          "kind": "method",
          "signature": "public startNewChild(): ServiceScope;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "ServiceScope",
            "description": [
              {
                "kind": "textDocElement",
                "value": "- the newly created root ServiceScope"
              }
            ]
          },
          "parameters": {},
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Constructs a new ServiceScope that is a child of the current scope. For any keys that are not explicitly provided by the child scope, the parent hierarchy will be consulted."
            }
          ]
        },
        "startNewRoot": {
          "kind": "method",
          "signature": "public static startNewRoot(): ServiceScope;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": true,
          "returnType": {
            "type": "ServiceScope",
            "description": [
              {
                "kind": "textDocElement",
                "value": "- the newly created root ServiceScope"
              }
            ]
          },
          "parameters": {},
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Create a new root-level ServiceScope. Only root-level scopes have the ability to autocreate default implementations of ServiceKeys."
            }
          ]
        },
        "whenFinished": {
          "kind": "method",
          "signature": "public whenFinished(callback: () => void): void;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "callback": {
              "name": "callback",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "A block of code that needs to call ServiceScope.consume()"
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "() => void"
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "It is an error to call ServiceScope.consume() before finish() has been called. The most reliable way to protect your component against this error is to perform the consume() calls inside a whenFinished() callback. If the service scope is already finished, then the callback will be executed immediately; otherwise, it will be executed later when the scope is finished."
            }
          ]
        }
      }
    },
    "TimeProvider": {
      "kind": "class",
      "implements": "ITimeProvider",
      "summary": [
        {
          "kind": "textDocElement",
          "value": "This is the default implementation of ITimeProvider that simply calls the real browser APIs."
        }
      ],
      "members": {
        "__constructor": {
          "kind": "method",
          "signature": "constructor(serviceScope: ServiceScope);",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "",
            "description": []
          },
          "parameters": {},
          "summary": []
        },
        "getDate": {
          "kind": "method",
          "signature": "public getDate(): Date;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "Date",
            "description": []
          },
          "parameters": {},
          "summary": []
        },
        "getTimestamp": {
          "kind": "method",
          "signature": "public getTimestamp(): number;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "number",
            "description": []
          },
          "parameters": {},
          "summary": []
        }
      }
    },
    "UrlQueryParameterCollection": {
      "kind": "class",
      "summary": [
        {
          "kind": "textDocElement",
          "value": "Class for storing and retrieving query parameters. The URL can be server-relative and it will parse empty/null strings. The query parameters must start with ? to indicate the first query parameter and use & for all subsequent parameters. The class also supports fragments. Edge cases behavior: Empty value (www.example.com/?test=) stores key and empty value No equals in queryParam (www.example.com/?test) stores key and undefined value Empty queryParam (www.example.com/?&debug=on) stores undefined key and value Query param with only equals (www.example.com/?=&debug=on stores empty string key and value"
        }
      ],
      "members": {
        "__constructor": {
          "kind": "method",
          "signature": "constructor(url: string);",
          "accessModifier": "",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "",
            "description": []
          },
          "parameters": {},
          "summary": []
        },
        "getValue": {
          "kind": "method",
          "signature": "public getValue(param: string): string;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "string",
            "description": []
          },
          "parameters": {
            "param": {
              "name": "param",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the case insensitive key for the desired query parameter value."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Returns the value of the first matching query parameter or undefined if the key doesn't exist. Examples: this._queryParameterList = [ {key: TEST, value: done}, {key: DEBUG, value: false}, {key: TEST, value: notdone}] getValue('TEST') ---> 'done' getValue('debug') ---> 'false' getValue('lost') ---> undefined"
            }
          ]
        },
        "getValues": {
          "kind": "method",
          "signature": "public getValues(param: string): string[];",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "string[]",
            "description": []
          },
          "parameters": {
            "param": {
              "name": "param",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the case insensitive key for the desired query parameter value."
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Returns the values of all of the matching query parameters or undefined if the key doesn't exist. Examples: this._queryParameterList = [ {key: TEST, value: done}, {key: DEBUG, value: false}, {key: TEST, value: notdone}] getValues('TEST') ---> ['done', 'notdone'] getValues('debug') ---> ['false'] getValues('lost') ---> undefined"
            }
          ]
        }
      }
    },
    "UrlUtilities": {
      "kind": "class",
      "summary": [
        {
          "kind": "textDocElement",
          "value": "Common helper functions for working with URLs. These utilities are intended to be simple, small, and very broadly applicable."
        }
      ],
      "members": {
        "convertToODataStringLiteral": {
          "kind": "method",
          "signature": "public static convertToODataStringLiteral(value: string): string;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": true,
          "returnType": {
            "type": "string",
            "description": []
          },
          "parameters": {},
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Converts a variable to an OData string literal suitable for usage in a REST URL. The returned string will be enclosed in single quotes, and any single quotes will be escaped. Example usage: const url = \"/_api/web/GetFolderByServerRelativeUrl(\" + UrlUtilities.convertToODataStringLiteral(\"/SitePages/Alice's%20Page\") + \")/Files\"; // Produces this URL: // \"/_api/web/GetFolderByServerRelativeUrl('/SitePages/Alice''s%20Page')/Files\""
            }
          ]
        },
        "removeEndSlash": {
          "kind": "method",
          "signature": "public static removeEndSlash(url: string): string;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": true,
          "returnType": {
            "type": "string",
            "description": []
          },
          "parameters": {
            "url": {
              "name": "url",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the URL to be normalized"
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Removes any slash characters from the end of the URL. This function assumes that the input is already a valid absolute or server-relative URL. Examples: removeEndSlash('http://example.com/') ---> 'http://example.com' removeEndSlash('/example') ---> '/example' removeEndSlash('/') ---> ''"
            }
          ]
        }
      }
    },
    "Validate": {
      "kind": "class",
      "summary": [
        {
          "kind": "textDocElement",
          "value": "This class implements provides a standard way to validate properties and function parameters. Unlike debug assertions, Validate checks are always performed and will always throw an error, even in a production release. As such, be careful not to overuse these checks in a way that might impact performance."
        }
      ],
      "members": {
        "isNonemptyString": {
          "kind": "method",
          "signature": "public static isNonemptyString(value: string, variableName: string): void;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": true,
          "returnType": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "value": {
              "name": "value",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the value to check"
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            },
            "variableName": {
              "name": "variableName",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the program variable name, which will be mentioned in the error message"
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Throws an exception if the specified string is null, undefined, or an empty string."
            }
          ]
        },
        "isNotNullOrUndefined": {
          "kind": "method",
          "signature": "public static isNotNullOrUndefined(value: any, variableName: string): void;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": true,
          "returnType": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "value": {
              "name": "value",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the value to check"
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "any"
            },
            "variableName": {
              "name": "variableName",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the program variable name, which will be mentioned in the error message"
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Throws an exception if the specified value is null or undefined."
            }
          ]
        },
        "isTrue": {
          "kind": "method",
          "signature": "public static isTrue(value: boolean, variableName: string): void;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": true,
          "returnType": {
            "type": "void",
            "description": []
          },
          "parameters": {
            "value": {
              "name": "value",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the value to check"
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "boolean"
            },
            "variableName": {
              "name": "variableName",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "the program variable name, which will be mentioned in the error message"
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Throws an exception if the specified value is not true."
            }
          ]
        }
      }
    },
    "Version": {
      "kind": "class",
      "summary": [
        {
          "kind": "textDocElement",
          "value": "This class represents versions that follow the string format of MAJOR.MINOR[.PATCH[.REVISION]] where MAJOR, MINOR, PATCH and REVISION are integers. PATCH and REVISION are optional. Leading zeros are allowed, but have no meaning in comparisons. Examples: 1.0, 1.0.0, 1.0.0.0, 1.01, 01.02.03, 001.002.003.004"
        }
      ],
      "members": {
        "equals": {
          "kind": "method",
          "signature": "public equals(compareWith: Version): boolean;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "boolean",
            "description": [
              {
                "kind": "textDocElement",
                "value": "A boolean indicating if this version is equal to the input parameter"
              }
            ]
          },
          "parameters": {
            "compareWith": {
              "name": "compareWith",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "The version to compare with"
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "Version"
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Checks if this version is equal to the input parameter. Missing patch number is treated as zero. Examples: 1.0.0 equals 1.0.0 -> true 2.0.1 equals 2.0.0 -> false 3.0 equals 3.0.0 -> true 04.01 equals 4.1 -> true"
            }
          ]
        },
        "greaterThan": {
          "kind": "method",
          "signature": "public greaterThan(compareWith: Version): boolean;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "boolean",
            "description": [
              {
                "kind": "textDocElement",
                "value": "A boolean indicating if this version is greater than the input parameter"
              }
            ]
          },
          "parameters": {
            "compareWith": {
              "name": "compareWith",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "The version to compare with"
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "Version"
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Checks if this version is greater (i.e. newer) than the input parameter. Missing patch number is treated as zero Examples: 1.0.0 greaterThan 0.0.9 -> true 2.0 greaterThan 2.0.0 -> false 3.0.1 greaterThan 3.0 -> true"
            }
          ]
        },
        "isValid": {
          "kind": "method",
          "signature": "public static isValid(versionString: string): boolean;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": true,
          "returnType": {
            "type": "boolean",
            "description": [
              {
                "kind": "textDocElement",
                "value": "Value indicating whether the version is valid."
              }
            ]
          },
          "parameters": {
            "versionString": {
              "name": "versionString",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "The version string"
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Indicates whether a version string is valid"
            }
          ]
        },
        "lessThan": {
          "kind": "method",
          "signature": "public lessThan(compareWith: Version): boolean;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "boolean",
            "description": [
              {
                "kind": "textDocElement",
                "value": "A boolean indicating if this version is less than the input parameter"
              }
            ]
          },
          "parameters": {
            "compareWith": {
              "name": "compareWith",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "The version to compare with"
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "Version"
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Checks if this version is less (i.e. older) than the input parameter. Missing patch number is treated as zero Examples: 0.9.9 lessThan 1.0.0 -> true 2.0 lessThan 2.0.0 -> false 3.0 lessThan 3.0.1 -> true 04.01 lessThan 4.1 -> false"
            }
          ]
        },
        "major": {
          "kind": "property",
          "isOptional": false,
          "isReadOnly": true,
          "isStatic": false,
          "type": "number",
          "summary": [
            {
              "kind": "textDocElement",
              "value": "The first number in the version string indicating the major version"
            }
          ]
        },
        "minor": {
          "kind": "property",
          "isOptional": false,
          "isReadOnly": true,
          "isStatic": false,
          "type": "number",
          "summary": [
            {
              "kind": "textDocElement",
              "value": "The second number in the version string indicating the minor version"
            }
          ]
        },
        "parse": {
          "kind": "method",
          "signature": "public static parse(versionString: string): Version;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": true,
          "returnType": {
            "type": "Version",
            "description": [
              {
                "kind": "textDocElement",
                "value": "If valid, a new Version instace"
              }
            ]
          },
          "parameters": {
            "versionString": {
              "name": "versionString",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "A version string"
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Constructs a new Version instance using the version string. tryParse validates the input version string and throws error if it is invalid"
            }
          ]
        },
        "patch": {
          "kind": "property",
          "isOptional": false,
          "isReadOnly": true,
          "isStatic": false,
          "type": "number",
          "summary": [
            {
              "kind": "textDocElement",
              "value": "The thrid number in the version string indicating the patch number in a semantic version or the build number in a .NET System.Version class Set to undefined if the third number does not exist"
            }
          ]
        },
        "revision": {
          "kind": "property",
          "isOptional": false,
          "isReadOnly": true,
          "isStatic": false,
          "type": "number",
          "summary": [
            {
              "kind": "textDocElement",
              "value": "The fourth number in the version string indicating the revision number Set to undefined if the fourth number does not exist"
            }
          ]
        },
        "toString": {
          "kind": "method",
          "signature": "public toString(): string;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": false,
          "returnType": {
            "type": "string",
            "description": []
          },
          "parameters": {},
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Object.prototype.toString override The version string in MAJOR.MINOR[.PATCH[.REVISION]]"
            }
          ]
        },
        "tryParse": {
          "kind": "method",
          "signature": "public static tryParse(versionString: string): Version;",
          "accessModifier": "public",
          "isOptional": false,
          "isStatic": true,
          "returnType": {
            "type": "Version",
            "description": [
              {
                "kind": "textDocElement",
                "value": "If valid, a new Version instace. Otherwise, undefined."
              }
            ]
          },
          "parameters": {
            "versionString": {
              "name": "versionString",
              "description": [
                {
                  "kind": "textDocElement",
                  "value": "A version string"
                }
              ],
              "isOptional": false,
              "isSpread": false,
              "type": "string"
            }
          },
          "summary": [
            {
              "kind": "textDocElement",
              "value": "Tries to construct a new Version instance using the version string. Returns undefined if not successful."
            }
          ]
        }
      }
    }
  }
}